 재귀함수란 자기 자신을 호출하는 함수를 말한다.

코드가 짧아져 가독성을 높일 수 있다는 장점이 있지만, 스택 오버 플로우를 일으킬 수 있는 엄청난 위험성도 내재하고있다.

함수를 호출할 때 함수의 입력 값(매개변수), 리턴값, 그리고 리턴됐을 때 돌아갈 위치값 등을 스택에 저장한다.
 재귀함수를 사용하면 함수가 끝나지 않은 채 연속적으로 함수를 호출하므로 스택에 메모리가 쌓이게 되고
 때문에 스택의 최대 크기 이상의 메모리가 쌓이게 되면 스택 오버 플로우가 일어나게 된다
 또한, 잦은 점프의 반복으로 성능이 저하될 위험도 가지고 있다.

 *재귀함수의 특징 정리
- 무한 루프에 빠지지 않기 위해 일정한 탈출 조건이 있어야 한다.
- 코드를 단순화 할 수 있다.
- 재귀 함수는 호출 시 마다 스택 공간을 이용하므로 무리하게 호출하면 스택 오버플로우가 일어날 수 있다.
- 재귀 함수의 호출 횟수는 스택의 남은 공간과 재귀 함수의 지역 변수 사이즈에 따라 달라진다.
- 디버깅 및 실행 흐름을 파악하기 힘들다.

 재귀는 장점도 있지만, 단점도 많기 때문에 사용에 주의를 기울여야 하는데, 이런 재귀함수의 단점을 보완하기 위한 꼬리 재귀라는 최적화 방법이 있습니다.

꼬리 재귀란, 재귀 호출이 끝난 후 현재 함수에서 추가 연산을 요구하지 않도록 구현하는 재귀의 형태
이를 이용하면 함수 호출이 반복되어 스택이 깊어지는 문제를 컴파일러가 선형으로 처리 하도록 알고리즘을 바꿔 스택을 재사용할 수 있게 됩니다.(더이상 값이 변할 여지가 없으므로 스택을 덮어쓸 수 있기 때문)
 이러한 꼬리 재귀를 사용하기 위해서는 컴파일러가 이런 최적화 기능을 지원하는지 먼저 확인해야 한다.
 (visual studio나 gcc는 지원합니다.) ,

 ** 일반재귀
 int factorial(int n){
 	if(n == 1) return 1;
     return n * factorial(n - 1);  // factorial 함수를 호출하면서 n *  라는 연산을 요구함
 }

 ** 꼬리재귀
int factorialTail(int n, int acc){
	if(n == 1) return acc;
    return factorialTail(n - 1, acc * n); // factorial을 호출하면서 연산을 요구하지 않음
}
int factorial(int n){
    return factorialTail(n, 1);
}

** 꼬리 재귀 최적화를 위한 조건 2가지
재귀 함수를 꼬리 재귀 방식으로 구현할 것
컴파일러가 꼬리 재귀 최적화를 지원할 것


C++, C#, Kotlin, Swift은 꼬리 재귀 최적화를 지원하며, JavaScript는 ES6 스펙에서 지원한다고 한다.

Java는 꼬리 재귀 최적화를 직접적으로 지원하지 않는다.
지원하지 않는 이유
jdk 클래스에는 보안에 민감한 메소드가 있다고 한다. 이 메소드들은 메소드 호출을 누가 했는지 알아내기 위해 jdk 라이브러리 코드와 호출 코드간의 스택 프레임 갯수에 의존한다. 스택 프레임 수의 변경을 유발하게 되면 이 의존관계를 망가뜨려 에러가 발생할 수 있다.