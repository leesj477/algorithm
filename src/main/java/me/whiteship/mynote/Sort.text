정렬 알고리즘 종류
버블정렬
선택정렬
삽입정렬
병합정렬
퀵정렬
팀정렬
기수정렬
그 외 많이 있으나 이정도만 알면 될듯 Java의 Arrays.sort()나 Colletions.sort()는 병합정렬, 팀정렬, 듀얼-피벗 퀵정렬을 사용한다


1. 버블정렬
버블정렬은 1번째와 2번째 원소를 비교하여 정렬하고, 2번째와 3번째, …, n-1번째와 n번째를 정렬한 뒤 다시 처음으로 돌아가 이번에는 n-2번째와 n-1번째까지, …해서 최대 n(n-1)/2번 정렬한다.
만들기가 쉽고 직관적일 뿐이지 알고리즘적 관점에서 보면 비효율적인 정렬 방식

시간복잡도 : O(n²)


2. 선택정렬
선택정렬은 1번째부터 끝까지 훑어서 가장 작은 게 1번째, 2번째부터 끝까지 훑어서 가장 작은 게 2번째……해서 (n-1)번 반복한다
사람이 사용하는 정렬 방식과 닮았다.

시간복잡도 : O(n²)

3. 삽입정렬
삽입정렬은 n번째 원소를 1부터 n-1까지와 비교해 적절한 위치에 끼워넣고 그 뒤의 자료를 한 칸씩 뒤로 밀어내는 방식으로, 평균적으론 O(n²)중 빠른 편이나 최악의 경우는 느리다

시간복잡도 : O(n²)

4. 병합정렬
병합정렬은 원소 개수가 1 또는 0이 될 때까지 두 부분으로 쪼개고 쪼개서 자른 순서의 역순으로 크기를 비교해 병합해 나간다. 성능은 아래의 퀵 정렬보다 전반적으로 뒤떨어지고, 데이터 크기만한 메모리가 더 필요하지만 stable sort(같은 값의 앞뒤가 순서가 바뀌지않음)이 최대 장점이다.

시간복잡도 : O(n*logN)

5. 퀵정렬
퀵정렬은 적절한 원소 하나를 기준(피벗, pivot)으로 삼아 그보다 작은 것을 앞으로 빼내고 그 뒤에 피벗을 옮겨 피벗보다 작은 것, 큰 것으로 나눈뒤 나누어진 각각에서 다시 피벗을 잡고 정렬해서 각각의 크기가 0이나 1이 될 때까지 정렬한다.
구현된 정렬 알고리즘 중 가장 고성능인 알고리즘이 바로 이 퀵정렬이다. 최악의 경우에는 시간복잡도가 O(n²)가 되는데, 피벗을 최솟값이나 최댓값으로 계속해서 잡게 되는 경우에 그렇다

시간복잡도 : O(n*logN) // 최악은 O(n²)

6. 팀정렬
팀정렬은 병합+삽입 정렬. 변형된 병합 정렬이다. 병합 정렬은 원소의 개수가 적을 때 오버헤드가 발생하기 때문에 파티션 크기가 특정 값 이하(보통 16 또는 32)가 되면 삽입 정렬을 사용한다. 병합 정렬과 비슷한 특징을 가지며 대부분의 경우 더 빠르다.

시간복잡도 : O(n*logN) // 병합정렬보다 빠름

7. 기수정렬
기수정렬은 낮은 자리수부터 비교하여 정렬해 간다는 것을 기본 개념으로 하는 정렬 알고리즘입니다. 기수정렬은 비교 연산을 하지 않으며 정렬 속도가 빠르지만 데이터 전체 크기에 기수 테이블의 크기만한 메모리가 더 필요합니다.